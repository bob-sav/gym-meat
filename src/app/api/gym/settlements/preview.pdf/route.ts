export const runtime = "nodejs";
export const dynamic = "force-dynamic";

import type { NextRequest } from "next/server";
import { PrismaClient } from "@prisma/client";
import PDFDocument from "pdfkit";
import fs from "node:fs";
import path from "node:path";
import { auth } from "@/auth";
import { formatHuf } from "@/lib/format";

const prisma = new PrismaClient();

function font(file: string) {
  return fs.readFileSync(path.join(process.cwd(), "public", "fonts", file));
}

export async function GET(req: NextRequest) {
  const session = await auth();
  const email = session?.user?.email ?? null;
  if (!email) return new Response("Unauthorized", { status: 401 });

  const url = new URL(req.url);
  const gymId = url.searchParams.get("gymId") ?? "";
  const disposition =
    url.searchParams.get("download") === "1" ? "attachment" : "inline";
  if (!gymId) return new Response("Missing gymId", { status: 400 });

  // Ensure caller is admin of this gym
  const isAdminOfGym = await prisma.gymAdmin.findFirst({
    where: { gymId, user: { email } },
    select: { id: true },
  });
  if (!isAdminOfGym) return new Response("Forbidden", { status: 403 });

  // Pull currently completed-but-unsettled orders for this gym
  const orders = await prisma.order.findMany({
    where: { pickupGymId: gymId, state: "PICKED_UP", gymSettlementId: null },
    select: { id: true, shortCode: true, totalCents: true, createdAt: true },
    orderBy: { createdAt: "asc" },
  });

  // Build PDF
  const doc = new PDFDocument({ size: "A4", margin: 50 });
  try {
    doc.registerFont("Body", font("Inter_18pt-Regular.ttf"));
    doc.registerFont("Bold", font("Inter_18pt-Bold.ttf"));
  } catch {}

  const chunks: Buffer[] = [];
  doc.on("data", (c) => chunks.push(c));
  const done = new Promise<Buffer>((r) =>
    doc.on("end", () => r(Buffer.concat(chunks)))
  );

  // Header
  doc
    .font("Bold")
    .fontSize(18)
    .text("Gym Settlement (Preview)", { align: "right" });
  doc.font("Body").moveDown(0.5);
  const gym = await prisma.gym.findUnique({
    where: { id: gymId },
    select: { name: true },
  });
  doc.fontSize(10).text(`Gym: ${gym?.name ?? gymId}`);
  doc.text(`Generated: ${new Date().toLocaleString()}`);
  doc.text(`Generated by: ${email}`);
  doc.moveDown();

  // Watermark "PREVIEW"
  doc
    .rotate(45, { origin: [300, 400] })
    .font("Bold")
    .fontSize(64)
    .fillColor("#eeeeee")
    .text("PREVIEW", 100, 200);
  doc.fillColor("#000").rotate(-45, { origin: [300, 400] });

  // Summary
  const totalCents = orders.reduce((s, o) => s + (o.totalCents || 0), 0);
  doc.fontSize(12).text(`Orders: ${orders.length}`);
  doc.text(`Total: ${formatHuf(totalCents)}`);
  doc.moveDown();

  // Table
  doc.fontSize(12).text("Orders (not yet settled):");
  doc.moveDown(0.5);
  doc.fontSize(10);
  const colX = [50, 250, 450]; // short code, date, total
  doc.text("Short code", colX[0], doc.y);
  doc.text("Date", colX[1], doc.y);
  doc.text("Total", colX[2], doc.y, { width: 100, align: "right" });
  doc.moveDown(0.2);
  doc.moveTo(50, doc.y).lineTo(545, doc.y).stroke();

  for (const o of orders) {
    doc.moveDown(0.2);
    doc.text(`#${o.shortCode ?? o.id.slice(0, 8)}`, colX[0], doc.y);
    doc.text(new Date(o.createdAt).toLocaleString(), colX[1], doc.y);
    doc.text(formatHuf(o.totalCents || 0), colX[2], doc.y, {
      width: 100,
      align: "right",
    });
  }

  doc.moveDown(2);
  doc
    .fontSize(9)
    .fillColor("#666")
    .text("This is a non-persistent preview. No orders were settled.", {
      align: "center",
    });
  doc.fillColor("#000");

  doc.end();
  const pdf = await done;

  return new Response(new Uint8Array(pdf), {
    status: 200,
    headers: {
      "Content-Type": "application/pdf",
      "Content-Disposition": `${disposition}; filename="gym-settlement-preview-${gym?.name ?? gymId}.pdf"`,
    },
  });
}
